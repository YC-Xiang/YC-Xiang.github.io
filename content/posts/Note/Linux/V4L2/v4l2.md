## 2.4 Video device

video device 用于向系统注册/dev 设备节点，以便用户空间可以进行交互.

`v4l2-dev.h`:

```c
struct video_device {
#if defined(CONFIG_MEDIA_CONTROLLER)
	struct media_entity entity;
	struct media_intf_devnode *intf_devnode;
	struct media_pipeline pipe;
#endif
	const struct v4l2_file_operations *fops;

	u32 device_caps;

	/* sysfs */
	struct device dev;
	struct cdev *cdev;

	struct v4l2_device *v4l2_dev;
	struct device *dev_parent;

	struct v4l2_ctrl_handler *ctrl_handler;

	struct vb2_queue *queue;

	struct v4l2_prio_state *prio;

	/* device info */
	char name[64];
	enum vfl_devnode_type vfl_type;
	enum vfl_devnode_direction vfl_dir;
	int minor;
	u16 num;
	unsigned long flags;
	int index;

	/* V4L2 file handles */
	spinlock_t		fh_lock;
	struct list_head	fh_list;

	int dev_debug;

	v4l2_std_id tvnorms;

	/* callbacks */
	void (*release)(struct video_device *vdev);
	const struct v4l2_ioctl_ops *ioctl_ops;
	DECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);

	struct mutex *lock;
};
```

APIs:

```c
int video_register_device(struct video_device *vdev,
				enum vfl_devnode_type type, int nr);
int video_register_device_no_warn(struct video_device *vdev,
			      enum vfl_devnode_type type, int nr);
void video_unregister_device(struct video_device *vdev);
struct video_device *video_device_alloc(void);
void video_device_release(struct video_device *vdev);
void video_device_release_empty(struct video_device *vdev);
```

video_device_release: 在 video_device 没有 subclass 的情况下, 释放 video_device 结构体.

video_device_release_empty: 空函数, 如果 video_device 是 static 分配的, 不需要释放使用该函数.

## 2.5 V4L2 device

v4l2 用来代表整个视频输入设备, 包含一系列子设备.

`v4l2-device.h`:

```c
struct v4l2_device {
	struct device *dev;
	struct media_device *mdev;
	struct list_head subdevs;
	spinlock_t lock;
	char name[36];
	void (*notify)(struct v4l2_subdev *sd,
			unsigned int notification, void *arg);
	struct v4l2_ctrl_handler *ctrl_handler;
	struct v4l2_prio_state prio;
	struct kref ref;
	void (*release)(struct v4l2_device *v4l2_dev);
};
```

dev: 底层 device 设备.

mdev: 指向 media device.

subdevs: 子设备列表.

name: v4l2 设备名称.

notify: 子设备调用的通知回调函数.

ctrl_handler: 控制句柄.

prio: 设备的优先级状态.

ref: 引用计数.

release: 释放回调函数.

通过`v4l2_device_register()`注册, `v4l2_device_unregister()`注销.

</br>

APIs:

```c
void v4l2_device_get(struct v4l2_device *v4l2_dev);
int v4l2_device_put(struct v4l2_device *v4l2_dev);
int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);
int v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,
			 atomic_t *instance);
void v4l2_device_disconnect(struct v4l2_device *v4l2_dev);
void v4l2_device_unregister(struct v4l2_device *v4l2_dev);

#define v4l2_device_register_subdev(v4l2_dev, sd) \
	__v4l2_device_register_subdev(v4l2_dev, sd, THIS_MODULE)
int __v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
				struct v4l2_subdev *sd,
				struct module *module);
void v4l2_device_unregister_subdev(struct v4l2_subdev *sd);
int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev);
int v4l2_device_register_ro_subdev_nodes(struct v4l2_device *v4l2_dev);
void v4l2_subdev_notify(struct v4l2_subdev *sd, unsigned int notification, void *arg);
bool v4l2_device_supports_requests(struct v4l2_device *v4l2_dev);
```

## 2.6 V4L2 File handlers

## 2.7 V4L2 sub-devices

```c
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
	struct media_entity entity;
#endif
	struct list_head list;
	struct module *owner;
	bool owner_v4l2_dev;
	u32 flags;
	struct v4l2_device *v4l2_dev;
	const struct v4l2_subdev_ops *ops;
	const struct v4l2_subdev_internal_ops *internal_ops;
	struct v4l2_ctrl_handler *ctrl_handler;
	char name[52];
	u32 grp_id;
	void *dev_priv;
	void *host_priv;
	struct video_device *devnode;
	struct device *dev;
	struct fwnode_handle *fwnode;
	struct list_head async_list;
	struct list_head async_subdev_endpoint_list;
	struct v4l2_async_notifier *subdev_notifier;
	struct list_head asc_list;
	struct v4l2_subdev_platform_data *pdata;
	struct mutex *state_lock;

	struct led_classdev *privacy_led;
	struct v4l2_subdev_state *active_state;
	u64 enabled_streams;
};
```

通过 `v4l2_subdev_init(sd, &ops)` 来初始化 v4l2_subdev. 接着需要设置 `sd->name`.

如果需要和 media framework 聚合, 那么需要初始化 media_entity 成员, 如果 entity 有 pads 还需要调用`media_entity_pads_init`.

### 2.7.1 Subdev registration

#### 2.7.1.1 Registering synchronous sub-devices

注册: `v4l2_device_register_subdev(v4l2_dev, sd)`

注销: `v4l2_device_unregister_subdev(sd)`

#### 2.7.1.2 Registering asynchronous sub-devices
