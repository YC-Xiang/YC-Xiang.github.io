## 2.4 Video device

video device 用于向系统注册/dev 设备节点，以便用户空间可以进行交互.

`v4l2-dev.h`:

```c
struct video_device {
#if defined(CONFIG_MEDIA_CONTROLLER)
	struct media_entity entity;
	struct media_intf_devnode *intf_devnode;
	struct media_pipeline pipe;
#endif
	const struct v4l2_file_operations *fops;

	u32 device_caps;

	/* sysfs */
	struct device dev;
	struct cdev *cdev;

	struct v4l2_device *v4l2_dev;
	struct device *dev_parent;

	struct v4l2_ctrl_handler *ctrl_handler;

	struct vb2_queue *queue;

	struct v4l2_prio_state *prio;

	/* device info */
	char name[64];
	enum vfl_devnode_type vfl_type;
	enum vfl_devnode_direction vfl_dir;
	int minor;
	u16 num;
	unsigned long flags;
	int index;

	/* V4L2 file handles */
	spinlock_t		fh_lock;
	struct list_head	fh_list;

	int dev_debug;

	v4l2_std_id tvnorms;

	/* callbacks */
	void (*release)(struct video_device *vdev);
	const struct v4l2_ioctl_ops *ioctl_ops;
	DECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);

	struct mutex *lock;
};
```

tvnorms: 支持的电视标准 PAL/NTSC/SECAM.

flags: enum v4l2_video_device_flags.

APIs:

```c
int video_register_device(struct video_device *vdev,
				enum vfl_devnode_type type, int nr);
int video_register_device_no_warn(struct video_device *vdev,
			      enum vfl_devnode_type type, int nr);
void video_unregister_device(struct video_device *vdev);
struct video_device *video_device_alloc(void);
void video_device_release(struct video_device *vdev);
void video_device_release_empty(struct video_device *vdev);
```

video_device_release: 在 video_device 没有 subclass 的情况下, 释放 video_device 结构体.

video_device_release_empty: 空函数, 如果 video_device 是 static 分配的, 不需要释放使用该函数.

## 2.5 V4L2 device

v4l2 用来代表整个视频输入设备, 包含一系列子设备.

`v4l2-device.h`:

```c
struct v4l2_device {
	struct device *dev;
	struct media_device *mdev;
	struct list_head subdevs;
	spinlock_t lock;
	char name[36];
	void (*notify)(struct v4l2_subdev *sd,
			unsigned int notification, void *arg);
	struct v4l2_ctrl_handler *ctrl_handler;
	struct v4l2_prio_state prio;
	struct kref ref;
	void (*release)(struct v4l2_device *v4l2_dev);
};
```

dev: 底层 device 设备.

mdev: 指向 media device.

subdevs: 子设备列表.

name: v4l2 设备名称.

notify: 子设备调用的通知回调函数.

ctrl_handler: 控制句柄.

prio: 设备的优先级状态.

ref: 引用计数.

release: 释放回调函数.

通过`v4l2_device_register()`注册, `v4l2_device_unregister()`注销.

</br>

APIs:

```c
void v4l2_device_get(struct v4l2_device *v4l2_dev);
int v4l2_device_put(struct v4l2_device *v4l2_dev);
int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);
int v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,
			 atomic_t *instance);
void v4l2_device_disconnect(struct v4l2_device *v4l2_dev);
void v4l2_device_unregister(struct v4l2_device *v4l2_dev);

#define v4l2_device_register_subdev(v4l2_dev, sd) \
	__v4l2_device_register_subdev(v4l2_dev, sd, THIS_MODULE)
int __v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
				struct v4l2_subdev *sd,
				struct module *module);
void v4l2_device_unregister_subdev(struct v4l2_subdev *sd);
int v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev);
int v4l2_device_register_ro_subdev_nodes(struct v4l2_device *v4l2_dev);
void v4l2_subdev_notify(struct v4l2_subdev *sd, unsigned int notification, void *arg);
bool v4l2_device_supports_requests(struct v4l2_device *v4l2_dev);
```

## 2.6 V4L2 File handlers

初始化: `v4l2_fh_init()`, 会置起 video_device 的 V4L2_FL_USES_V4L2_FH flag.

在 userspace open device node 后, 调用到 v4l2_fh_open, 会把 file->private_data 设置为 fh.

```c
struct v4l2_fh {
	struct list_head	list;
	struct video_device	*vdev;
	struct v4l2_ctrl_handler *ctrl_handler;
	enum v4l2_priority	prio;

	wait_queue_head_t	wait;
	struct mutex		subscribe_lock;
	struct list_head	subscribed;
	struct list_head	available;
	unsigned int		navailable;
	u32			sequence;

	struct v4l2_m2m_ctx	*m2m_ctx;
};
```

## 2.7 V4L2 sub-devices

对于 webcams, 常见的 sub-devices 有 sensors, camera controllers.

通过 `v4l2_subdev_init(sd, &ops)` 来初始化 v4l2_subdev. 接着需要设置 `sd->name`.

如果需要和 media framework 聚合, 那么需要初始化 media_entity 成员, 如果 entity 有 pads 还需要调用`media_entity_pads_init`.

```c
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
	struct media_entity entity;
#endif
	struct list_head list;
	struct module *owner;
	bool owner_v4l2_dev;
	u32 flags;
	struct v4l2_device *v4l2_dev;
	const struct v4l2_subdev_ops *ops;
	const struct v4l2_subdev_internal_ops *internal_ops;
	struct v4l2_ctrl_handler *ctrl_handler;
	char name[52];
	u32 grp_id;
	void *dev_priv;
	void *host_priv;
	struct video_device *devnode;
	struct device *dev;
	struct fwnode_handle *fwnode;
	struct list_head async_list;
	struct list_head async_subdev_endpoint_list;
	struct v4l2_async_notifier *subdev_notifier;
	struct list_head asc_list;
	struct v4l2_subdev_platform_data *pdata;
	struct mutex *state_lock;

	struct led_classdev *privacy_led;
	struct v4l2_subdev_state *active_state;
	u64 enabled_streams;
};
```

owner_v4l2_dev: 如果和 v4l2_dev->dev 的 owner 一致, 则为 true.

flags: V4L2_SUBDEV_FL_IS_I2C 表示是 I2C 设备, V4L2_SUBDEV_FL_IS_SPI 表示是 SPI 设备,
V4L2_SUBDEV_FL_HAS_DEVNODE 表示需要 device node, V4L2_SUBDEV_FL_HAS_EVENTS 表示会生成 events.
V4L2_SUBDEV_FL_STREAMS 表示支持 multiplexed streams.

v4l2_dev: 指向 v4l2_device.

ops:

internal_ops:

ctrl_handler:

e.g.

```c
static const struct v4l2_subdev_pad_ops rkisp1_isp_pad_ops = {
	...
};

static const struct v4l2_subdev_video_ops rkisp1_isp_video_ops = {
	...
};

static const struct v4l2_subdev_core_ops rkisp1_isp_core_ops = {
	...
};

static const struct v4l2_subdev_ops rkisp1_isp_ops = {
	.core = &rkisp1_isp_core_ops,
	.video = &rkisp1_isp_video_ops,
	.pad = &rkisp1_isp_pad_ops,
	...
};

v4l2_subdev_init(sd, &rkisp1_isp_ops);
```

### 2.7.1 Subdev registration

V4L2 子设备注册的方式有两种.

第一种是由 bridge driver 来注册 subdevices. 适用于 internal subdevices, 比如 video data processing units,
camera sensor.

第二种是 bridge driver 和 subdevice 异步注册. 适用于 subdevices 的信息不是在 bridge driver 中,
而是比如在设备树中定义的 i2c 设备.

#### 2.7.1.1 Registering synchronous sub-devices

和 bridge driver 同步注册.

注册: `v4l2_device_register_subdev(v4l2_dev, sd)`

注销: `v4l2_device_unregister_subdev(sd)`

#### 2.7.1.2 Registering asynchronous sub-devices

和 bridge driver 异步注册.

注册: `v4l2_async_register_subdev(v4l2_dev, sd)`

注销: `v4l2_async_unregister_subdev(sd)`

#### 2.7.1.3 Asynchronous sub-device notifiers

Bridge driver 需要注册一个 notifier object.

注册: `v4l2_async_nf_register()`

注销: `v4l2_async_nf_unregister()`, 在释放 unregistered notifier 前, 还需要调用`v4l2_async_nf_cleanup()`.

注册 notifier 前, bridge driver 首先需要调用`v4l2_async_nf_init()`, 接着可以通过`v4l2_async_nf_add_fwnode()`, `v4l2_async_nf_add_fwnode_remote()` 和 `v4l2_async_nf_add_i2c()` 来获取 bridge device 需要的 connection descriptor.

#### 2.7.1.4 Asynchronous sub-device notifier for sub-devices

`v4l2_async_subdev_nf_init()`

#### 2.7.1.5 Asynchronous sub-device registration helper for camera sensor drivers

`v4l2_async_register_subdev_sensor()`

#### 2.7.1.7 Asynchronous sub-device notifier callbacks

V4L2 core 会利用 connection descriptors 来匹配异步注册的 subdevices.

connection match 之后调用.bound()回调, 所有 connections 都 bound 之后调用.complete()回调.

connection remove 之后调用.unbind()回调.

### 2.7.2 Calling subdev operations

调用 subdev 的 ops 回调, 使用如下宏:

`v4l2_subdev_call()`

调用所有或一组 subdev 的 ops:

`v4l2_device_call_all()`

`v4l2_device_call_until_err()`

## 2.8 V4L2 sub-device userspace API

## 2.13 data structures and functions
